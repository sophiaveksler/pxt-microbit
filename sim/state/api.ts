/**
 * Adafruit IO REST API
 * ### The Internet of Things for Everyone  The Adafruit IO HTTP API provides access to your Adafruit IO data from any programming language or hardware environment that can speak HTTP. The easiest way to get started is with [an Adafruit IO learn guide](https://learn.adafruit.com/series/adafruit-io-basics) and [a simple Internet of Things capable device like the Feather Huzzah](https://www.adafruit.com/product/2821).  This API documentation is hosted on GitHub Pages and is available at [https://github.com/adafruit/io-api](https://github.com/adafruit/io-api). For questions or comments visit the [Adafruit IO Forums](https://forums.adafruit.com/viewforum.php?f=56) or the [adafruit-io channel on the Adafruit Discord server](https://discord.gg/adafruit).  #### Authentication  Authentication for every API request happens through the `X-AIO-Key` header or query parameter and your IO API key. A simple cURL request to get all available feeds for a user with the username \"io_username\" and the key \"io_key_12345\" could look like this:      $ curl -H \"X-AIO-Key: io_key_12345\" https://io.adafruit.com/api/v2/io_username/feeds  Or like this:      $ curl \"https://io.adafruit.com/api/v2/io_username/feeds?X-AIO-Key=io_key_12345  Using the node.js [request](https://github.com/request/request) library, IO HTTP requests are as easy as:  ```js var request = require('request');  var options = {   url: 'https://io.adafruit.com/api/v2/io_username/feeds',   headers: {     'X-AIO-Key': 'io_key_12345',     'Content-Type': 'application/json'   } };  function callback(error, response, body) {   if (!error && response.statusCode == 200) {     var feeds = JSON.parse(body);     console.log(feeds.length + \" FEEDS AVAILABLE\");      feeds.forEach(function (feed) {       console.log(feed.name, feed.key);     })   } }  request(options, callback); ```  Using the ESP8266 Arduino HTTPClient library, an HTTPS GET request would look like this (replacing `---` with your own values in the appropriate locations):  ```arduino /// based on /// https://github.com/esp8266/Arduino/blob/master/libraries/ESP8266HTTPClient/examples/Authorization/Authorization.ino  #include <Arduino.h> #include <ESP8266WiFi.h> #include <ESP8266WiFiMulti.h> #include <ESP8266HTTPClient.h>  ESP8266WiFiMulti WiFiMulti;  const char* ssid = \"---\"; const char* password = \"---\";  const char* host = \"io.adafruit.com\";  const char* io_key = \"---\"; const char* path_with_username = \"/api/v2/---/dashboards\";  // Use web browser to view and copy // SHA1 fingerprint of the certificate const char* fingerprint = \"77 00 54 2D DA E7 D8 03 27 31 23 99 EB 27 DB CB A5 4C 57 18\";  void setup() {   Serial.begin(115200);    for(uint8_t t = 4; t > 0; t--) {     Serial.printf(\"[SETUP] WAIT %d...\\n\", t);     Serial.flush();     delay(1000);   }    WiFi.mode(WIFI_STA);   WiFiMulti.addAP(ssid, password);    // wait for WiFi connection   while(WiFiMulti.run() != WL_CONNECTED) {     Serial.print('.');     delay(1000);   }    Serial.println(\"[WIFI] connected!\");    HTTPClient http;    // start request with URL and TLS cert fingerprint for verification   http.begin(\"https://\" + String(host) + String(path_with_username), fingerprint);    // IO API authentication   http.addHeader(\"X-AIO-Key\", io_key);    // start connection and send HTTP header   int httpCode = http.GET();    // httpCode will be negative on error   if(httpCode > 0) {     // HTTP header has been send and Server response header has been handled     Serial.printf(\"[HTTP] GET response: %d\\n\", httpCode);      // HTTP 200 OK     if(httpCode == HTTP_CODE_OK) {       String payload = http.getString();       Serial.println(payload);     }      http.end();   } }  void loop() {} ```  #### Client Libraries  We have client libraries to help you get started with your project: [Python](https://github.com/adafruit/io-client-python), [Ruby](https://github.com/adafruit/io-client-ruby), [Arduino C++](https://github.com/adafruit/Adafruit_IO_Arduino), [Javascript](https://github.com/adafruit/adafruit-io-node), and [Go](https://github.com/adafruit/io-client-go) are available. They're all open source, so if they don't already do what you want, you can fork and add any feature you'd like.  
 *
 * OpenAPI spec version: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/// <reference path="../../node_modules/pxt-core/typings/globals/node/index.d.ts"/>
/// <reference path="../../node_modules/pxt-core/typings/modules/request/index.d.ts"/>
/// <reference path="../../node_modules/pxt-core/built/pxtsim.d.ts"/>

//declare const localVarRequest: typeof request = require('request')
//declare const http: typeof http = require('http')
//declare const Promise: typeof bluebird = require('bluebird')
import * as localVarRequest from "request"
import * as http from "http"
//import * as Promise from "bluebird"


export namespace api {
let defaultBasePath = 'https://io.adafruit.com/api/v2';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class Activity {
    'id': number;
    'action': string;
    'model': string;
    'data': any;
    'userId': number;
    'createdAt': string;
    'updatedAt': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        },
        {
            "name": "model",
            "baseName": "model",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "any"
        },
        {
            "name": "userId",
            "baseName": "user_id",
            "type": "number"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Activity.attributeTypeMap;
    }
}

export class Block {
    'name': string;
    'description': string;
    'key': string;
    'dashboardId': number;
    'visualType': string;
    'column': number;
    'row': number;
    'sizeX': number;
    'sizeY': number;
    'blockFeeds': Array<UsernamedashboardsdashboardIdblocksBlockFeeds>;
    'properties': any;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "dashboardId",
            "baseName": "dashboard_id",
            "type": "number"
        },
        {
            "name": "visualType",
            "baseName": "visual_type",
            "type": "string"
        },
        {
            "name": "column",
            "baseName": "column",
            "type": "number"
        },
        {
            "name": "row",
            "baseName": "row",
            "type": "number"
        },
        {
            "name": "sizeX",
            "baseName": "size_x",
            "type": "number"
        },
        {
            "name": "sizeY",
            "baseName": "size_y",
            "type": "number"
        },
        {
            "name": "blockFeeds",
            "baseName": "block_feeds",
            "type": "Array<UsernamedashboardsdashboardIdblocksBlockFeeds>"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return Block.attributeTypeMap;
    }
}

export class BlockFeed {
    'id': string;
    'feed': Feed;
    'group': Group;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "feed",
            "baseName": "feed",
            "type": "Feed"
        },
        {
            "name": "group",
            "baseName": "group",
            "type": "Group"
        }    ];

    static getAttributeTypeMap() {
        return BlockFeed.attributeTypeMap;
    }
}

export class Dashboard {
    'name': string;
    'description': string;
    'key': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Dashboard.attributeTypeMap;
    }
}

export class Data {
    'value': string;
    'createdAt': string;
    'lat': string;
    'lon': string;
    'ele': string;
    'epoch': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "lat",
            "baseName": "lat",
            "type": "string"
        },
        {
            "name": "lon",
            "baseName": "lon",
            "type": "string"
        },
        {
            "name": "ele",
            "baseName": "ele",
            "type": "string"
        },
        {
            "name": "epoch",
            "baseName": "epoch",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Data.attributeTypeMap;
    }
}

export class DataResponse {
    'id': string;
    'value': string;
    'feedId': number;
    'groupId': number;
    'expiration': string;
    'lat': number;
    'lon': number;
    'ele': number;
    'completedAt': string;
    'createdAt': string;
    'updatedAt': string;
    'createdEpoch': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "feedId",
            "baseName": "feed_id",
            "type": "number"
        },
        {
            "name": "groupId",
            "baseName": "group_id",
            "type": "number"
        },
        {
            "name": "expiration",
            "baseName": "expiration",
            "type": "string"
        },
        {
            "name": "lat",
            "baseName": "lat",
            "type": "number"
        },
        {
            "name": "lon",
            "baseName": "lon",
            "type": "number"
        },
        {
            "name": "ele",
            "baseName": "ele",
            "type": "number"
        },
        {
            "name": "completedAt",
            "baseName": "completed_at",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        },
        {
            "name": "createdEpoch",
            "baseName": "created_epoch",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DataResponse.attributeTypeMap;
    }
}

export class Datum {
    'value': string;
    'createdAt': string;
    'lat': string;
    'lon': string;
    'ele': string;
    'epoch': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "lat",
            "baseName": "lat",
            "type": "string"
        },
        {
            "name": "lon",
            "baseName": "lon",
            "type": "string"
        },
        {
            "name": "ele",
            "baseName": "ele",
            "type": "string"
        },
        {
            "name": "epoch",
            "baseName": "epoch",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Datum.attributeTypeMap;
    }
}

export class Feed {
    'name': string;
    'key': string;
    'description': string;
    'license': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "license",
            "baseName": "license",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Feed.attributeTypeMap;
    }
}

/**
* Additional details about this feed.
*/
export class FeedDetails {
    /**
    * Access control list for this feed
    */
    'sharedWith': Array<any>;
    'data': FeedDetailsData;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sharedWith",
            "baseName": "shared_with",
            "type": "Array<any>"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "FeedDetailsData"
        }    ];

    static getAttributeTypeMap() {
        return FeedDetails.attributeTypeMap;
    }
}

export class FeedDetailsData {
    'first': { [key: string]: Data; };
    'last': { [key: string]: Data; };
    /**
    * Number of data points stored by this feed.
    */
    'count': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "first",
            "baseName": "first",
            "type": "{ [key: string]: Data; }"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "{ [key: string]: Data; }"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return FeedDetailsData.attributeTypeMap;
    }
}

export class Group {
    'name': string;
    'description': string;
    'key': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Group.attributeTypeMap;
    }
}

export class GroupFeedData {
    'location': UsernamegroupsgroupKeydataLocation;
    /**
    * An array of feed data records with `key` and `value` properties.
    */
    'feeds': Array<UsernamegroupsgroupKeydataFeeds>;
    /**
    * Optional created_at timestamp which will be applied to all feed values created.
    */
    'createdAt': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "location",
            "baseName": "location",
            "type": "UsernamegroupsgroupKeydataLocation"
        },
        {
            "name": "feeds",
            "baseName": "feeds",
            "type": "Array<UsernamegroupsgroupKeydataFeeds>"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GroupFeedData.attributeTypeMap;
    }
}

export class InlineResponse200 {
    /**
    * Max possible actions inside the time window (usually 1 minute).
    */
    'dataRateLimit': number;
    /**
    * Actions taken inside the time window.
    */
    'activeDataRate': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dataRateLimit",
            "baseName": "data_rate_limit",
            "type": "number"
        },
        {
            "name": "activeDataRate",
            "baseName": "active_data_rate",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse200.attributeTypeMap;
    }
}

export class InlineResponse2001 {
    'feed': InlineResponse2001Feed;
    'parameters': any;
    /**
    * The names of the columns returned as data.
    */
    'columns': Array<string>;
    /**
    * The actual chart data.
    */
    'data': Array<Array<string>>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "feed",
            "baseName": "feed",
            "type": "InlineResponse2001Feed"
        },
        {
            "name": "parameters",
            "baseName": "parameters",
            "type": "any"
        },
        {
            "name": "columns",
            "baseName": "columns",
            "type": "Array<string>"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<Array<string>>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2001.attributeTypeMap;
    }
}

export class InlineResponse2001Feed {
    'id': number;
    'key': string;
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2001Feed.attributeTypeMap;
    }
}

export class ModelError {
    'code': string;
    'message': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ModelError.attributeTypeMap;
    }
}

export class Permission {
    'mode': Permission.ModeEnum;
    'scope': Permission.ScopeEnum;
    'scopeValue': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mode",
            "baseName": "mode",
            "type": "Permission.ModeEnum"
        },
        {
            "name": "scope",
            "baseName": "scope",
            "type": "Permission.ScopeEnum"
        },
        {
            "name": "scopeValue",
            "baseName": "scope_value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Permission.attributeTypeMap;
    }
}

export namespace Permission {
    export enum ModeEnum {
        R = <any> 'r',
        W = <any> 'w',
        Rw = <any> 'rw'
    }
    export enum ScopeEnum {
        Secret = <any> 'secret',
        Public = <any> 'public',
        User = <any> 'user',
        Organization = <any> 'organization'
    }
}
export class ShallowGroup {
    'id': number;
    'name': string;
    'description': string;
    'createdAt': string;
    'updatedAt': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ShallowGroup.attributeTypeMap;
    }
}

export class Token {
    'token': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Token.attributeTypeMap;
    }
}

export class Trigger {
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Trigger.attributeTypeMap;
    }
}

export class User {
    'id': number;
    'name': string;
    'color': string;
    'username': string;
    'timeZone': string;
    'createdAt': string;
    'updatedAt': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "timeZone",
            "baseName": "time_zone",
            "type": "string"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "string"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return User.attributeTypeMap;
    }
}

export class UsernamedashboardsdashboardIdblocksBlockFeeds {
    'feedId': string;
    'groupId': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "feedId",
            "baseName": "feed_id",
            "type": "string"
        },
        {
            "name": "groupId",
            "baseName": "group_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UsernamedashboardsdashboardIdblocksBlockFeeds.attributeTypeMap;
    }
}

export class UsernamegroupsgroupKeydataFeeds {
    'key': string;
    'value': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UsernamegroupsgroupKeydataFeeds.attributeTypeMap;
    }
}

/**
* A location record with `lat`, `lon`, and [optional] `ele` properties.
*/
export class UsernamegroupsgroupKeydataLocation {
    'lat': number;
    'lon': number;
    'ele': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lat",
            "baseName": "lat",
            "type": "number"
        },
        {
            "name": "lon",
            "baseName": "lon",
            "type": "number"
        },
        {
            "name": "ele",
            "baseName": "ele",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UsernamegroupsgroupKeydataLocation.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "Permission.ModeEnum": Permission.ModeEnum,
        "Permission.ScopeEnum": Permission.ScopeEnum,
}

let typeMap: {[index: string]: any} = {
    "Activity": Activity,
    "Block": Block,
    "BlockFeed": BlockFeed,
    "Dashboard": Dashboard,
    "Data": Data,
    "DataResponse": DataResponse,
    "Datum": Datum,
    "Feed": Feed,
    "FeedDetails": FeedDetails,
    "FeedDetailsData": FeedDetailsData,
    "Group": Group,
    "GroupFeedData": GroupFeedData,
    "InlineResponse200": InlineResponse200,
    "InlineResponse2001": InlineResponse2001,
    "InlineResponse2001Feed": InlineResponse2001Feed,
    "ModelError": ModelError,
    "Permission": Permission,
    "ShallowGroup": ShallowGroup,
    "Token": Token,
    "Trigger": Trigger,
    "User": User,
    "UsernamedashboardsdashboardIdblocksBlockFeeds": UsernamedashboardsdashboardIdblocksBlockFeeds,
    "UsernamegroupsgroupKeydataFeeds": UsernamegroupsgroupKeydataFeeds,
    "UsernamegroupsgroupKeydataLocation": UsernamegroupsgroupKeydataLocation,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum ActivitiesApiApiKeys {
    HeaderKey,
    HeaderSignature,
    QueryKey,
}

export class ActivitiesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'HeaderKey': new ApiKeyAuth('header', 'X-AIO-Key'),
        'HeaderSignature': new ApiKeyAuth('header', 'X-AIO-Signature'),
        'QueryKey': new ApiKeyAuth('query', 'X-AIO-Key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ActivitiesApiApiKeys, value: string) {
        (this.authentications as any)[ActivitiesApiApiKeys[key]].apiKey = value;
    }
    /**
     * The Activities endpoint returns information about the user's activities.
     * @summary All activities for current user
     * @param username a valid username string
     * @param startTime Start time for filtering, returns records created after given time.
     * @param endTime End time for filtering, returns records created before give time.
     * @param limit Limit the number of records returned.
     */
    public allActivities (username: string, startTime?: Date, endTime?: Date, limit?: number) : Promise<{ response: http.ClientResponse; body: Array<Activity>;  }> {
        const localVarPath = this.basePath + '/{username}/activities'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling allActivities.');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['start_time'] = ObjectSerializer.serialize(startTime, "Date");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['end_time'] = ObjectSerializer.serialize(endTime, "Date");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Activity>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Activity>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete all your activities.
     * @summary All activities for current user
     * @param username a valid username string
     */
    public destroyActivities (username: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/{username}/activities'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling destroyActivities.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The Activities endpoint returns information about the user's activities.
     * @summary Get activities by type for current user
     * @param username a valid username string
     * @param type 
     * @param startTime Start time for filtering, returns records created after given time.
     * @param endTime End time for filtering, returns records created before give time.
     * @param limit Limit the number of records returned.
     */
    public getActivity (username: string, type: string, startTime?: Date, endTime?: Date, limit?: number) : Promise<{ response: http.ClientResponse; body: Array<Activity>;  }> {
        const localVarPath = this.basePath + '/{username}/activities/{type}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'type' + '}', encodeURIComponent(String(type)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling getActivity.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling getActivity.');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['start_time'] = ObjectSerializer.serialize(startTime, "Date");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['end_time'] = ObjectSerializer.serialize(endTime, "Date");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Activity>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Activity>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BlocksApiApiKeys {
    HeaderKey,
    HeaderSignature,
    QueryKey,
}

export class BlocksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'HeaderKey': new ApiKeyAuth('header', 'X-AIO-Key'),
        'HeaderSignature': new ApiKeyAuth('header', 'X-AIO-Signature'),
        'QueryKey': new ApiKeyAuth('query', 'X-AIO-Key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BlocksApiApiKeys, value: string) {
        (this.authentications as any)[BlocksApiApiKeys[key]].apiKey = value;
    }
    /**
     * The Blocks endpoint returns information about the user's blocks. 
     * @summary All blocks for current user
     * @param username a valid username string
     * @param dashboardId 
     */
    public allBlocks (username: string, dashboardId: string) : Promise<{ response: http.ClientResponse; body: Array<Block>;  }> {
        const localVarPath = this.basePath + '/{username}/dashboards/{dashboard_id}/blocks'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'dashboard_id' + '}', encodeURIComponent(String(dashboardId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling allBlocks.');
        }

        // verify required parameter 'dashboardId' is not null or undefined
        if (dashboardId === null || dashboardId === undefined) {
            throw new Error('Required parameter dashboardId was null or undefined when calling allBlocks.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Block>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Block>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new Block
     * @param username a valid username string
     * @param block 
     * @param dashboardId 
     */
    public createBlock (username: string, block: Block, dashboardId: string) : Promise<{ response: http.ClientResponse; body: Block;  }> {
        const localVarPath = this.basePath + '/{username}/dashboards/{dashboard_id}/blocks'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'dashboard_id' + '}', encodeURIComponent(String(dashboardId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling createBlock.');
        }

        // verify required parameter 'block' is not null or undefined
        if (block === null || block === undefined) {
            throw new Error('Required parameter block was null or undefined when calling createBlock.');
        }

        // verify required parameter 'dashboardId' is not null or undefined
        if (dashboardId === null || dashboardId === undefined) {
            throw new Error('Required parameter dashboardId was null or undefined when calling createBlock.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(block, "Block")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Block;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Block");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an existing Block
     * @param username a valid username string
     * @param dashboardId 
     * @param id 
     */
    public destroyBlock (username: string, dashboardId: string, id: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/{username}/dashboards/{dashboard_id}/blocks/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'dashboard_id' + '}', encodeURIComponent(String(dashboardId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling destroyBlock.');
        }

        // verify required parameter 'dashboardId' is not null or undefined
        if (dashboardId === null || dashboardId === undefined) {
            throw new Error('Required parameter dashboardId was null or undefined when calling destroyBlock.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling destroyBlock.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns Block based on ID
     * @param username a valid username string
     * @param dashboardId 
     * @param id 
     */
    public getBlock (username: string, dashboardId: string, id: string) : Promise<{ response: http.ClientResponse; body: Block;  }> {
        const localVarPath = this.basePath + '/{username}/dashboards/{dashboard_id}/blocks/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'dashboard_id' + '}', encodeURIComponent(String(dashboardId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling getBlock.');
        }

        // verify required parameter 'dashboardId' is not null or undefined
        if (dashboardId === null || dashboardId === undefined) {
            throw new Error('Required parameter dashboardId was null or undefined when calling getBlock.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBlock.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Block;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Block");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Replace an existing Block
     * @param username a valid username string
     * @param dashboardId 
     * @param id 
     * @param block 
     */
    public replaceBlock (username: string, dashboardId: string, id: string, block: Block) : Promise<{ response: http.ClientResponse; body: Block;  }> {
        const localVarPath = this.basePath + '/{username}/dashboards/{dashboard_id}/blocks/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'dashboard_id' + '}', encodeURIComponent(String(dashboardId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling replaceBlock.');
        }

        // verify required parameter 'dashboardId' is not null or undefined
        if (dashboardId === null || dashboardId === undefined) {
            throw new Error('Required parameter dashboardId was null or undefined when calling replaceBlock.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling replaceBlock.');
        }

        // verify required parameter 'block' is not null or undefined
        if (block === null || block === undefined) {
            throw new Error('Required parameter block was null or undefined when calling replaceBlock.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(block, "Block")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Block;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Block");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update properties of an existing Block
     * @param username a valid username string
     * @param dashboardId 
     * @param id 
     * @param block 
     */
    public updateBlock (username: string, dashboardId: string, id: string, block: Block) : Promise<{ response: http.ClientResponse; body: Block;  }> {
        const localVarPath = this.basePath + '/{username}/dashboards/{dashboard_id}/blocks/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'dashboard_id' + '}', encodeURIComponent(String(dashboardId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling updateBlock.');
        }

        // verify required parameter 'dashboardId' is not null or undefined
        if (dashboardId === null || dashboardId === undefined) {
            throw new Error('Required parameter dashboardId was null or undefined when calling updateBlock.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateBlock.');
        }

        // verify required parameter 'block' is not null or undefined
        if (block === null || block === undefined) {
            throw new Error('Required parameter block was null or undefined when calling updateBlock.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(block, "Block")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Block;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Block");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DashboardsApiApiKeys {
    HeaderKey,
    HeaderSignature,
    QueryKey,
}

export class DashboardsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'HeaderKey': new ApiKeyAuth('header', 'X-AIO-Key'),
        'HeaderSignature': new ApiKeyAuth('header', 'X-AIO-Signature'),
        'QueryKey': new ApiKeyAuth('query', 'X-AIO-Key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DashboardsApiApiKeys, value: string) {
        (this.authentications as any)[DashboardsApiApiKeys[key]].apiKey = value;
    }
    /**
     * The Dashboards endpoint returns information about the user's dashboards. 
     * @summary All dashboards for current user
     * @param username a valid username string
     */
    public allDashboards (username: string) : Promise<{ response: http.ClientResponse; body: Array<Dashboard>;  }> {
        const localVarPath = this.basePath + '/{username}/dashboards'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling allDashboards.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Dashboard>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Dashboard>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new Dashboard
     * @param username a valid username string
     * @param dashboard 
     */
    public createDashboard (username: string, dashboard: Dashboard) : Promise<{ response: http.ClientResponse; body: Dashboard;  }> {
        const localVarPath = this.basePath + '/{username}/dashboards'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling createDashboard.');
        }

        // verify required parameter 'dashboard' is not null or undefined
        if (dashboard === null || dashboard === undefined) {
            throw new Error('Required parameter dashboard was null or undefined when calling createDashboard.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(dashboard, "Dashboard")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Dashboard;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Dashboard");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an existing Dashboard
     * @param username a valid username string
     * @param id 
     */
    public destroyDashboard (username: string, id: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/{username}/dashboards/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling destroyDashboard.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling destroyDashboard.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns Dashboard based on ID
     * @param username a valid username string
     * @param id 
     */
    public getDashboard (username: string, id: string) : Promise<{ response: http.ClientResponse; body: Dashboard;  }> {
        const localVarPath = this.basePath + '/{username}/dashboards/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling getDashboard.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDashboard.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Dashboard;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Dashboard");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Replace an existing Dashboard
     * @param username a valid username string
     * @param id 
     * @param dashboard 
     */
    public replaceDashboard (username: string, id: string, dashboard: Dashboard) : Promise<{ response: http.ClientResponse; body: Dashboard;  }> {
        const localVarPath = this.basePath + '/{username}/dashboards/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling replaceDashboard.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling replaceDashboard.');
        }

        // verify required parameter 'dashboard' is not null or undefined
        if (dashboard === null || dashboard === undefined) {
            throw new Error('Required parameter dashboard was null or undefined when calling replaceDashboard.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(dashboard, "Dashboard")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Dashboard;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Dashboard");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update properties of an existing Dashboard
     * @param username a valid username string
     * @param id 
     * @param dashboard 
     */
    public updateDashboard (username: string, id: string, dashboard: Dashboard) : Promise<{ response: http.ClientResponse; body: Dashboard;  }> {
        const localVarPath = this.basePath + '/{username}/dashboards/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling updateDashboard.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateDashboard.');
        }

        // verify required parameter 'dashboard' is not null or undefined
        if (dashboard === null || dashboard === undefined) {
            throw new Error('Required parameter dashboard was null or undefined when calling updateDashboard.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(dashboard, "Dashboard")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Dashboard;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Dashboard");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DataApiApiKeys {
    HeaderKey,
    HeaderSignature,
    QueryKey,
}

export class DataApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'HeaderKey': new ApiKeyAuth('header', 'X-AIO-Key'),
        'HeaderSignature': new ApiKeyAuth('header', 'X-AIO-Signature'),
        'QueryKey': new ApiKeyAuth('query', 'X-AIO-Key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DataApiApiKeys, value: string) {
        (this.authentications as any)[DataApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get all data for the given feed
     * @param username a valid username string
     * @param feedKey a valid feed key
     * @param startTime Start time for filtering, returns records created after given time.
     * @param endTime End time for filtering, returns records created before give time.
     * @param limit Limit the number of records returned.
     * @param include List of Data record fields to include in response as comma separated list. Acceptable values are: &#x60;value&#x60;, &#x60;lat&#x60;, &#x60;lon&#x60;, &#x60;ele&#x60;, &#x60;id&#x60;, and &#x60;created_at&#x60;. 
     */
    public allData (username: string, feedKey: string, startTime?: Date, endTime?: Date, limit?: number, include?: string) : Promise<{ response: http.ClientResponse; body: Array<DataResponse>;  }> {
        const localVarPath = this.basePath + '/{username}/feeds/{feed_key}/data'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling allData.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling allData.');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['start_time'] = ObjectSerializer.serialize(startTime, "Date");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['end_time'] = ObjectSerializer.serialize(endTime, "Date");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DataResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<DataResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary All data for current feed in a specific group
     * @param username a valid username string
     * @param groupKey 
     * @param feedKey a valid feed key
     * @param startTime Start time for filtering data. Returns data created after given time.
     * @param endTime End time for filtering data. Returns data created before give time.
     * @param limit Limit the number of records returned.
     */
    public allGroupFeedData (username: string, groupKey: string, feedKey: string, startTime?: Date, endTime?: Date, limit?: number) : Promise<{ response: http.ClientResponse; body: Array<DataResponse>;  }> {
        const localVarPath = this.basePath + '/{username}/groups/{group_key}/feeds/{feed_key}/data'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'group_key' + '}', encodeURIComponent(String(groupKey)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling allGroupFeedData.');
        }

        // verify required parameter 'groupKey' is not null or undefined
        if (groupKey === null || groupKey === undefined) {
            throw new Error('Required parameter groupKey was null or undefined when calling allGroupFeedData.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling allGroupFeedData.');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['start_time'] = ObjectSerializer.serialize(startTime, "Date");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['end_time'] = ObjectSerializer.serialize(endTime, "Date");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DataResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<DataResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create multiple new Data records
     * @param username a valid username string
     * @param feedKey a valid feed key
     * @param data A collection of data records including &#x60;value&#x60; (required) and optionally including: &#x60;lat&#x60;, &#x60;lon&#x60;, &#x60;ele&#x60; (latitude, longitude, and elevation values), and &#x60;created_at&#x60; (a date/time string).
     */
    public batchCreateData (username: string, feedKey: string, data: Array<Data>) : Promise<{ response: http.ClientResponse; body: Array<DataResponse>;  }> {
        const localVarPath = this.basePath + '/{username}/feeds/{feed_key}/data/batch'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling batchCreateData.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling batchCreateData.');
        }

        // verify required parameter 'data' is not null or undefined
        if (data === null || data === undefined) {
            throw new Error('Required parameter data was null or undefined when calling batchCreateData.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<Data>")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DataResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<DataResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create multiple new Data records in a feed belonging to a particular group
     * @param username a valid username string
     * @param groupKey 
     * @param feedKey a valid feed key
     * @param data A collection of data records including &#x60;value&#x60; (required) and optionally including: &#x60;lat&#x60;, &#x60;lon&#x60;, &#x60;ele&#x60; (latitude, longitude, and elevation values), and &#x60;created_at&#x60; (a date/time string).
     */
    public batchCreateGroupFeedData (username: string, groupKey: string, feedKey: string, data: Array<Data>) : Promise<{ response: http.ClientResponse; body: Array<DataResponse>;  }> {
        const localVarPath = this.basePath + '/{username}/groups/{group_key}/feeds/{feed_key}/data/batch'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'group_key' + '}', encodeURIComponent(String(groupKey)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling batchCreateGroupFeedData.');
        }

        // verify required parameter 'groupKey' is not null or undefined
        if (groupKey === null || groupKey === undefined) {
            throw new Error('Required parameter groupKey was null or undefined when calling batchCreateGroupFeedData.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling batchCreateGroupFeedData.');
        }

        // verify required parameter 'data' is not null or undefined
        if (data === null || data === undefined) {
            throw new Error('Required parameter data was null or undefined when calling batchCreateGroupFeedData.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(data, "Array<Data>")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DataResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<DataResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The Chart API is what we use on io.adafruit.com to populate charts over varying timespans with a consistent number of data points. The maximum number of points returned is 480. This API works by aggregating slices of time into a single value by averaging.  All time-based parameters are optional, if none are given it will default to 1 hour at the finest-grained resolution possible.
     * @summary Chart data for current feed
     * @param username a valid username string
     * @param feedKey a valid feed key
     * @param startTime Start time for filtering, returns records created after given time.
     * @param endTime End time for filtering, returns records created before give time.
     * @param resolution A resolution size in minutes. By giving a resolution value you will get back grouped data points aggregated over resolution-sized intervals. NOTE: time span is preferred over resolution, so if you request a span of time that includes more than max limit points you may get a larger resolution than you requested. Valid resolutions are 1, 5, 10, 30, 60, and 120.
     * @param hours The number of hours the chart should cover.
     */
    public chartData (username: string, feedKey: string, startTime?: Date, endTime?: Date, resolution?: number, hours?: number) : Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }> {
        const localVarPath = this.basePath + '/{username}/feeds/{feed_key}/data/chart'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling chartData.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling chartData.');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['start_time'] = ObjectSerializer.serialize(startTime, "Date");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['end_time'] = ObjectSerializer.serialize(endTime, "Date");
        }

        if (resolution !== undefined) {
            localVarQueryParameters['resolution'] = ObjectSerializer.serialize(resolution, "number");
        }

        if (hours !== undefined) {
            localVarQueryParameters['hours'] = ObjectSerializer.serialize(hours, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2001");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create new Data
     * @param username a valid username string
     * @param feedKey a valid feed key
     * @param datum Data record including a &#x60;value&#x60; field (required) and optionally including: &#x60;lat&#x60;, &#x60;lon&#x60;, &#x60;ele&#x60; (latitude, longitude, and elevation values), and &#x60;created_at&#x60; (a date/time string).
     */
    public createData (username: string, feedKey: string, datum: Datum) : Promise<{ response: http.ClientResponse; body: Data;  }> {
        const localVarPath = this.basePath + '/{username}/feeds/{feed_key}/data'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling createData.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling createData.');
        }

        // verify required parameter 'datum' is not null or undefined
        if (datum === null || datum === undefined) {
            throw new Error('Required parameter datum was null or undefined when calling createData.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(datum, "Datum")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Data;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Data");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create new data for multiple feeds in a group
     * @param username a valid username string
     * @param groupKey 
     * @param groupFeedData 
     */
    public createGroupData (username: string, groupKey: string, groupFeedData: GroupFeedData) : Promise<{ response: http.ClientResponse; body: Array<DataResponse>;  }> {
        const localVarPath = this.basePath + '/{username}/groups/{group_key}/data'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'group_key' + '}', encodeURIComponent(String(groupKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling createGroupData.');
        }

        // verify required parameter 'groupKey' is not null or undefined
        if (groupKey === null || groupKey === undefined) {
            throw new Error('Required parameter groupKey was null or undefined when calling createGroupData.');
        }

        // verify required parameter 'groupFeedData' is not null or undefined
        if (groupFeedData === null || groupFeedData === undefined) {
            throw new Error('Required parameter groupFeedData was null or undefined when calling createGroupData.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(groupFeedData, "GroupFeedData")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DataResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<DataResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create new Data in a feed belonging to a particular group
     * @param username a valid username string
     * @param groupKey 
     * @param feedKey a valid feed key
     * @param datum Data record including a &#x60;value&#x60; field (required) and optionally including: &#x60;lat&#x60;, &#x60;lon&#x60;, &#x60;ele&#x60; (latitude, longitude, and elevation values), and &#x60;created_at&#x60; (a date/time string).
     */
    public createGroupFeedData (username: string, groupKey: string, feedKey: string, datum: Datum) : Promise<{ response: http.ClientResponse; body: DataResponse;  }> {
        const localVarPath = this.basePath + '/{username}/groups/{group_key}/feeds/{feed_key}/data'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'group_key' + '}', encodeURIComponent(String(groupKey)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling createGroupFeedData.');
        }

        // verify required parameter 'groupKey' is not null or undefined
        if (groupKey === null || groupKey === undefined) {
            throw new Error('Required parameter groupKey was null or undefined when calling createGroupFeedData.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling createGroupFeedData.');
        }

        // verify required parameter 'datum' is not null or undefined
        if (datum === null || datum === undefined) {
            throw new Error('Required parameter datum was null or undefined when calling createGroupFeedData.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(datum, "Datum")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DataResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete existing Data
     * @param username a valid username string
     * @param feedKey a valid feed key
     * @param id 
     */
    public destroyData (username: string, feedKey: string, id: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/{username}/feeds/{feed_key}/data/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling destroyData.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling destroyData.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling destroyData.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the oldest data point in the feed. This request sets the queue pointer to the beginning of the feed.
     * @summary First Data in Queue
     * @param username a valid username string
     * @param feedKey a valid feed key
     * @param include List of Data record fields to include in response as comma separated list. Acceptable values are: &#x60;value&#x60;, &#x60;lat&#x60;, &#x60;lon&#x60;, &#x60;ele&#x60;, &#x60;id&#x60;, and &#x60;created_at&#x60;. 
     */
    public firstData (username: string, feedKey: string, include?: string) : Promise<{ response: http.ClientResponse; body: DataResponse;  }> {
        const localVarPath = this.basePath + '/{username}/feeds/{feed_key}/data/first'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling firstData.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling firstData.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DataResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns data based on feed key
     * @param username a valid username string
     * @param feedKey a valid feed key
     * @param id 
     * @param include List of Data record fields to include in response as comma separated list. Acceptable values are: &#x60;value&#x60;, &#x60;lat&#x60;, &#x60;lon&#x60;, &#x60;ele&#x60;, &#x60;id&#x60;, and &#x60;created_at&#x60;. 
     */
    public getData (username: string, feedKey: string, id: string, include?: string) : Promise<{ response: http.ClientResponse; body: DataResponse;  }> {
        const localVarPath = this.basePath + '/{username}/feeds/{feed_key}/data/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling getData.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling getData.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getData.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DataResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the most recent data point in the feed. This request sets the queue pointer to the end of the feed.
     * @summary Last Data in Queue
     * @param username a valid username string
     * @param feedKey a valid feed key
     * @param include List of Data record fields to include in response as comma separated list. Acceptable values are: &#x60;value&#x60;, &#x60;lat&#x60;, &#x60;lon&#x60;, &#x60;ele&#x60;, &#x60;id&#x60;, and &#x60;created_at&#x60;. 
     */
    public lastData (username: string, feedKey: string, include?: string) : Promise<{ response: http.ClientResponse; body: DataResponse;  }> {
        const localVarPath = this.basePath + '/{username}/feeds/{feed_key}/data/last'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling lastData.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling lastData.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DataResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the next newest data point in the feed. If queue processing hasn't been started, the first data point in the feed will be returned.
     * @summary Next Data in Queue
     * @param username a valid username string
     * @param feedKey a valid feed key
     * @param include List of Data record fields to include in response as comma separated list. Acceptable values are: &#x60;value&#x60;, &#x60;lat&#x60;, &#x60;lon&#x60;, &#x60;ele&#x60;, &#x60;id&#x60;, and &#x60;created_at&#x60;. 
     */
    public nextData (username: string, feedKey: string, include?: string) : Promise<{ response: http.ClientResponse; body: DataResponse;  }> {
        const localVarPath = this.basePath + '/{username}/feeds/{feed_key}/data/next'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling nextData.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling nextData.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DataResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the previously processed data point in the feed. NOTE: this method doesn't move the processing queue pointer.
     * @summary Previous Data in Queue
     * @param username a valid username string
     * @param feedKey a valid feed key
     * @param include List of Data record fields to include in response as comma separated list. Acceptable values are: &#x60;value&#x60;, &#x60;lat&#x60;, &#x60;lon&#x60;, &#x60;ele&#x60;, &#x60;id&#x60;, and &#x60;created_at&#x60;. 
     */
    public previousData (username: string, feedKey: string, include?: string) : Promise<{ response: http.ClientResponse; body: DataResponse;  }> {
        const localVarPath = this.basePath + '/{username}/feeds/{feed_key}/data/previous'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling previousData.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling previousData.');
        }

        if (include !== undefined) {
            localVarQueryParameters['include'] = ObjectSerializer.serialize(include, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DataResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Replace existing Data
     * @param username a valid username string
     * @param feedKey a valid feed key
     * @param id 
     * @param datum Data record including a &#x60;value&#x60; field (required) and optionally including: &#x60;lat&#x60;, &#x60;lon&#x60;, &#x60;ele&#x60; (latitude, longitude, and elevation values), and &#x60;created_at&#x60; (a date/time string).
     */
    public replaceData (username: string, feedKey: string, id: string, datum: Datum) : Promise<{ response: http.ClientResponse; body: DataResponse;  }> {
        const localVarPath = this.basePath + '/{username}/feeds/{feed_key}/data/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling replaceData.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling replaceData.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling replaceData.');
        }

        // verify required parameter 'datum' is not null or undefined
        if (datum === null || datum === undefined) {
            throw new Error('Required parameter datum was null or undefined when calling replaceData.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(datum, "Datum")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DataResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the most recent data point in the feed in an MQTT compatible CSV format: `value,lat,lon,ele`
     * @summary Last Data in MQTT CSV format
     * @param username a valid username string
     * @param feedKey a valid feed key
     */
    public retainData (username: string, feedKey: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/{username}/feeds/{feed_key}/data/retain'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling retainData.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling retainData.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update properties of existing Data
     * @param username a valid username string
     * @param feedKey a valid feed key
     * @param id 
     * @param datum Data record including a &#x60;value&#x60; field (required) and optionally including: &#x60;lat&#x60;, &#x60;lon&#x60;, &#x60;ele&#x60; (latitude, longitude, and elevation values), and &#x60;created_at&#x60; (a date/time string).
     */
    public updateData (username: string, feedKey: string, id: string, datum: Datum) : Promise<{ response: http.ClientResponse; body: DataResponse;  }> {
        const localVarPath = this.basePath + '/{username}/feeds/{feed_key}/data/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling updateData.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling updateData.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateData.');
        }

        // verify required parameter 'datum' is not null or undefined
        if (datum === null || datum === undefined) {
            throw new Error('Required parameter datum was null or undefined when calling updateData.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(datum, "Datum")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DataResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DataResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FeedsApiApiKeys {
    HeaderKey,
    HeaderSignature,
    QueryKey,
}

export class FeedsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'HeaderKey': new ApiKeyAuth('header', 'X-AIO-Key'),
        'HeaderSignature': new ApiKeyAuth('header', 'X-AIO-Signature'),
        'QueryKey': new ApiKeyAuth('query', 'X-AIO-Key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FeedsApiApiKeys, value: string) {
        (this.authentications as any)[FeedsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add an existing Feed to a Group
     * @param groupKey 
     * @param username a valid username string
     * @param feedKey 
     */
    public addFeedToGroup (groupKey: string, username: string, feedKey?: string) : Promise<{ response: http.ClientResponse; body: Group;  }> {
        const localVarPath = this.basePath + '/{username}/groups/{group_key}/add'
            .replace('{' + 'group_key' + '}', encodeURIComponent(String(groupKey)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupKey' is not null or undefined
        if (groupKey === null || groupKey === undefined) {
            throw new Error('Required parameter groupKey was null or undefined when calling addFeedToGroup.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling addFeedToGroup.');
        }

        if (feedKey !== undefined) {
            localVarQueryParameters['feed_key'] = ObjectSerializer.serialize(feedKey, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Group;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Group");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The Feeds endpoint returns information about the user's feeds. The response includes the latest value of each feed, and other metadata about each feed.
     * @summary All feeds for current user
     * @param username a valid username string
     */
    public allFeeds (username: string) : Promise<{ response: http.ClientResponse; body: Array<Feed>;  }> {
        const localVarPath = this.basePath + '/{username}/feeds'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling allFeeds.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Feed>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Feed>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The Group Feeds endpoint returns information about the user's feeds. The response includes the latest value of each feed, and other metadata about each feed, but only for feeds within the given group.
     * @summary All feeds for current user in a given group
     * @param groupKey 
     * @param username a valid username string
     */
    public allGroupFeeds (groupKey: string, username: string) : Promise<{ response: http.ClientResponse; body: Array<Feed>;  }> {
        const localVarPath = this.basePath + '/{username}/groups/{group_key}/feeds'
            .replace('{' + 'group_key' + '}', encodeURIComponent(String(groupKey)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupKey' is not null or undefined
        if (groupKey === null || groupKey === undefined) {
            throw new Error('Required parameter groupKey was null or undefined when calling allGroupFeeds.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling allGroupFeeds.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Feed>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Feed>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new Feed
     * @param username a valid username string
     * @param feed 
     * @param groupKey 
     */
    public createFeed (username: string, feed: Feed, groupKey?: string) : Promise<{ response: http.ClientResponse; body: Feed;  }> {
        const localVarPath = this.basePath + '/{username}/feeds'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling createFeed.');
        }

        // verify required parameter 'feed' is not null or undefined
        if (feed === null || feed === undefined) {
            throw new Error('Required parameter feed was null or undefined when calling createFeed.');
        }

        if (groupKey !== undefined) {
            localVarQueryParameters['group_key'] = ObjectSerializer.serialize(groupKey, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(feed, "Feed")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Feed;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Feed");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new Feed in a Group
     * @param username a valid username string
     * @param groupKey 
     * @param feed 
     */
    public createGroupFeed (username: string, groupKey: string, feed: Feed) : Promise<{ response: http.ClientResponse; body: Feed;  }> {
        const localVarPath = this.basePath + '/{username}/groups/{group_key}/feeds'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'group_key' + '}', encodeURIComponent(String(groupKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling createGroupFeed.');
        }

        // verify required parameter 'groupKey' is not null or undefined
        if (groupKey === null || groupKey === undefined) {
            throw new Error('Required parameter groupKey was null or undefined when calling createGroupFeed.');
        }

        // verify required parameter 'feed' is not null or undefined
        if (feed === null || feed === undefined) {
            throw new Error('Required parameter feed was null or undefined when calling createGroupFeed.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(feed, "Feed")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Feed;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Feed");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an existing Feed
     * @param username a valid username string
     * @param feedKey a valid feed key
     */
    public destroyFeed (username: string, feedKey: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/{username}/feeds/{feed_key}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling destroyFeed.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling destroyFeed.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns feed based on the feed key
     * @summary Get feed by feed key
     * @param username a valid username string
     * @param feedKey a valid feed key
     */
    public getFeed (username: string, feedKey: string) : Promise<{ response: http.ClientResponse; body: Feed;  }> {
        const localVarPath = this.basePath + '/{username}/feeds/{feed_key}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling getFeed.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling getFeed.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Feed;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Feed");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns more detailed feed record based on the feed key
     * @summary Get detailed feed by feed key
     * @param username a valid username string
     * @param feedKey a valid feed key
     */
    public getFeedDetails (username: string, feedKey: string) : Promise<{ response: http.ClientResponse; body: Feed;  }> {
        const localVarPath = this.basePath + '/{username}/feeds/{feed_key}/details'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling getFeedDetails.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling getFeedDetails.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Feed;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Feed");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove a Feed from a Group
     * @param groupKey 
     * @param username a valid username string
     * @param feedKey 
     */
    public removeFeedFromGroup (groupKey: string, username: string, feedKey?: string) : Promise<{ response: http.ClientResponse; body: Group;  }> {
        const localVarPath = this.basePath + '/{username}/groups/{group_key}/remove'
            .replace('{' + 'group_key' + '}', encodeURIComponent(String(groupKey)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupKey' is not null or undefined
        if (groupKey === null || groupKey === undefined) {
            throw new Error('Required parameter groupKey was null or undefined when calling removeFeedFromGroup.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling removeFeedFromGroup.');
        }

        if (feedKey !== undefined) {
            localVarQueryParameters['feed_key'] = ObjectSerializer.serialize(feedKey, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Group;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Group");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Replace an existing Feed
     * @param username a valid username string
     * @param feedKey a valid feed key
     * @param feed 
     */
    public replaceFeed (username: string, feedKey: string, feed: Feed) : Promise<{ response: http.ClientResponse; body: Feed;  }> {
        const localVarPath = this.basePath + '/{username}/feeds/{feed_key}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling replaceFeed.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling replaceFeed.');
        }

        // verify required parameter 'feed' is not null or undefined
        if (feed === null || feed === undefined) {
            throw new Error('Required parameter feed was null or undefined when calling replaceFeed.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(feed, "Feed")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Feed;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Feed");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update properties of an existing Feed
     * @param username a valid username string
     * @param feedKey a valid feed key
     * @param feed 
     */
    public updateFeed (username: string, feedKey: string, feed: Feed) : Promise<{ response: http.ClientResponse; body: Feed;  }> {
        const localVarPath = this.basePath + '/{username}/feeds/{feed_key}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'feed_key' + '}', encodeURIComponent(String(feedKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling updateFeed.');
        }

        // verify required parameter 'feedKey' is not null or undefined
        if (feedKey === null || feedKey === undefined) {
            throw new Error('Required parameter feedKey was null or undefined when calling updateFeed.');
        }

        // verify required parameter 'feed' is not null or undefined
        if (feed === null || feed === undefined) {
            throw new Error('Required parameter feed was null or undefined when calling updateFeed.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(feed, "Feed")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Feed;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Feed");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GroupsApiApiKeys {
    HeaderKey,
    HeaderSignature,
    QueryKey,
}

export class GroupsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'HeaderKey': new ApiKeyAuth('header', 'X-AIO-Key'),
        'HeaderSignature': new ApiKeyAuth('header', 'X-AIO-Signature'),
        'QueryKey': new ApiKeyAuth('query', 'X-AIO-Key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GroupsApiApiKeys, value: string) {
        (this.authentications as any)[GroupsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add an existing Feed to a Group
     * @param groupKey 
     * @param username a valid username string
     * @param feedKey 
     */
    public addFeedToGroup (groupKey: string, username: string, feedKey?: string) : Promise<{ response: http.ClientResponse; body: Group;  }> {
        const localVarPath = this.basePath + '/{username}/groups/{group_key}/add'
            .replace('{' + 'group_key' + '}', encodeURIComponent(String(groupKey)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupKey' is not null or undefined
        if (groupKey === null || groupKey === undefined) {
            throw new Error('Required parameter groupKey was null or undefined when calling addFeedToGroup.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling addFeedToGroup.');
        }

        if (feedKey !== undefined) {
            localVarQueryParameters['feed_key'] = ObjectSerializer.serialize(feedKey, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Group;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Group");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The Group Feeds endpoint returns information about the user's feeds. The response includes the latest value of each feed, and other metadata about each feed, but only for feeds within the given group.
     * @summary All feeds for current user in a given group
     * @param groupKey 
     * @param username a valid username string
     */
    public allGroupFeeds (groupKey: string, username: string) : Promise<{ response: http.ClientResponse; body: Array<Feed>;  }> {
        const localVarPath = this.basePath + '/{username}/groups/{group_key}/feeds'
            .replace('{' + 'group_key' + '}', encodeURIComponent(String(groupKey)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupKey' is not null or undefined
        if (groupKey === null || groupKey === undefined) {
            throw new Error('Required parameter groupKey was null or undefined when calling allGroupFeeds.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling allGroupFeeds.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Feed>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Feed>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The Groups endpoint returns information about the user's groups. The response includes the latest value of each feed in the group, and other metadata about the group. 
     * @summary All groups for current user
     * @param username a valid username string
     */
    public allGroups (username: string) : Promise<{ response: http.ClientResponse; body: Array<Group>;  }> {
        const localVarPath = this.basePath + '/{username}/groups'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling allGroups.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Group>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Group>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new Group
     * @param username a valid username string
     * @param group 
     */
    public createGroup (username: string, group: Group) : Promise<{ response: http.ClientResponse; body: Group;  }> {
        const localVarPath = this.basePath + '/{username}/groups'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling createGroup.');
        }

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling createGroup.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(group, "Group")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Group;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Group");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an existing Group
     * @param username a valid username string
     * @param groupKey 
     */
    public destroyGroup (username: string, groupKey: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/{username}/groups/{group_key}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'group_key' + '}', encodeURIComponent(String(groupKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling destroyGroup.');
        }

        // verify required parameter 'groupKey' is not null or undefined
        if (groupKey === null || groupKey === undefined) {
            throw new Error('Required parameter groupKey was null or undefined when calling destroyGroup.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns Group based on ID
     * @param username a valid username string
     * @param groupKey 
     */
    public getGroup (username: string, groupKey: string) : Promise<{ response: http.ClientResponse; body: Group;  }> {
        const localVarPath = this.basePath + '/{username}/groups/{group_key}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'group_key' + '}', encodeURIComponent(String(groupKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling getGroup.');
        }

        // verify required parameter 'groupKey' is not null or undefined
        if (groupKey === null || groupKey === undefined) {
            throw new Error('Required parameter groupKey was null or undefined when calling getGroup.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Group;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Group");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove a Feed from a Group
     * @param groupKey 
     * @param username a valid username string
     * @param feedKey 
     */
    public removeFeedFromGroup (groupKey: string, username: string, feedKey?: string) : Promise<{ response: http.ClientResponse; body: Group;  }> {
        const localVarPath = this.basePath + '/{username}/groups/{group_key}/remove'
            .replace('{' + 'group_key' + '}', encodeURIComponent(String(groupKey)))
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'groupKey' is not null or undefined
        if (groupKey === null || groupKey === undefined) {
            throw new Error('Required parameter groupKey was null or undefined when calling removeFeedFromGroup.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling removeFeedFromGroup.');
        }

        if (feedKey !== undefined) {
            localVarQueryParameters['feed_key'] = ObjectSerializer.serialize(feedKey, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Group;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Group");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Replace an existing Group
     * @param username a valid username string
     * @param groupKey 
     * @param group 
     */
    public replaceGroup (username: string, groupKey: string, group: Group) : Promise<{ response: http.ClientResponse; body: Group;  }> {
        const localVarPath = this.basePath + '/{username}/groups/{group_key}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'group_key' + '}', encodeURIComponent(String(groupKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling replaceGroup.');
        }

        // verify required parameter 'groupKey' is not null or undefined
        if (groupKey === null || groupKey === undefined) {
            throw new Error('Required parameter groupKey was null or undefined when calling replaceGroup.');
        }

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling replaceGroup.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(group, "Group")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Group;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Group");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update properties of an existing Group
     * @param username a valid username string
     * @param groupKey 
     * @param group 
     */
    public updateGroup (username: string, groupKey: string, group: Group) : Promise<{ response: http.ClientResponse; body: Group;  }> {
        const localVarPath = this.basePath + '/{username}/groups/{group_key}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'group_key' + '}', encodeURIComponent(String(groupKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling updateGroup.');
        }

        // verify required parameter 'groupKey' is not null or undefined
        if (groupKey === null || groupKey === undefined) {
            throw new Error('Required parameter groupKey was null or undefined when calling updateGroup.');
        }

        // verify required parameter 'group' is not null or undefined
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling updateGroup.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(group, "Group")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Group;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Group");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PermissionsApiApiKeys {
    HeaderKey,
    HeaderSignature,
    QueryKey,
}

export class PermissionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'HeaderKey': new ApiKeyAuth('header', 'X-AIO-Key'),
        'HeaderSignature': new ApiKeyAuth('header', 'X-AIO-Signature'),
        'QueryKey': new ApiKeyAuth('query', 'X-AIO-Key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PermissionsApiApiKeys, value: string) {
        (this.authentications as any)[PermissionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * The Permissions endpoint returns information about the user's permissions. 
     * @summary All permissions for current user and type
     * @param username a valid username string
     * @param type 
     * @param typeId 
     */
    public allPermissions (username: string, type: string, typeId: string) : Promise<{ response: http.ClientResponse; body: Array<Permission>;  }> {
        const localVarPath = this.basePath + '/{username}/{type}/{type_id}/acl'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'type' + '}', encodeURIComponent(String(type)))
            .replace('{' + 'type_id' + '}', encodeURIComponent(String(typeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling allPermissions.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling allPermissions.');
        }

        // verify required parameter 'typeId' is not null or undefined
        if (typeId === null || typeId === undefined) {
            throw new Error('Required parameter typeId was null or undefined when calling allPermissions.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Permission>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Permission>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new Permission
     * @param username a valid username string
     * @param type 
     * @param typeId 
     * @param permission 
     */
    public createPermission (username: string, type: string, typeId: string, permission: Permission) : Promise<{ response: http.ClientResponse; body: Permission;  }> {
        const localVarPath = this.basePath + '/{username}/{type}/{type_id}/acl'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'type' + '}', encodeURIComponent(String(type)))
            .replace('{' + 'type_id' + '}', encodeURIComponent(String(typeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling createPermission.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling createPermission.');
        }

        // verify required parameter 'typeId' is not null or undefined
        if (typeId === null || typeId === undefined) {
            throw new Error('Required parameter typeId was null or undefined when calling createPermission.');
        }

        // verify required parameter 'permission' is not null or undefined
        if (permission === null || permission === undefined) {
            throw new Error('Required parameter permission was null or undefined when calling createPermission.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(permission, "Permission")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Permission;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Permission");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an existing Permission
     * @param username a valid username string
     * @param type 
     * @param typeId 
     * @param id 
     */
    public destroyPermission (username: string, type: string, typeId: string, id: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/{username}/{type}/{type_id}/acl/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'type' + '}', encodeURIComponent(String(type)))
            .replace('{' + 'type_id' + '}', encodeURIComponent(String(typeId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling destroyPermission.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling destroyPermission.');
        }

        // verify required parameter 'typeId' is not null or undefined
        if (typeId === null || typeId === undefined) {
            throw new Error('Required parameter typeId was null or undefined when calling destroyPermission.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling destroyPermission.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns Permission based on ID
     * @param username a valid username string
     * @param type 
     * @param typeId 
     * @param id 
     */
    public getPermission (username: string, type: string, typeId: string, id: string) : Promise<{ response: http.ClientResponse; body: Permission;  }> {
        const localVarPath = this.basePath + '/{username}/{type}/{type_id}/acl/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'type' + '}', encodeURIComponent(String(type)))
            .replace('{' + 'type_id' + '}', encodeURIComponent(String(typeId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling getPermission.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling getPermission.');
        }

        // verify required parameter 'typeId' is not null or undefined
        if (typeId === null || typeId === undefined) {
            throw new Error('Required parameter typeId was null or undefined when calling getPermission.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPermission.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Permission;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Permission");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Replace an existing Permission
     * @param username a valid username string
     * @param type 
     * @param typeId 
     * @param id 
     * @param permission 
     */
    public replacePermission (username: string, type: string, typeId: string, id: string, permission: Permission) : Promise<{ response: http.ClientResponse; body: Permission;  }> {
        const localVarPath = this.basePath + '/{username}/{type}/{type_id}/acl/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'type' + '}', encodeURIComponent(String(type)))
            .replace('{' + 'type_id' + '}', encodeURIComponent(String(typeId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling replacePermission.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling replacePermission.');
        }

        // verify required parameter 'typeId' is not null or undefined
        if (typeId === null || typeId === undefined) {
            throw new Error('Required parameter typeId was null or undefined when calling replacePermission.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling replacePermission.');
        }

        // verify required parameter 'permission' is not null or undefined
        if (permission === null || permission === undefined) {
            throw new Error('Required parameter permission was null or undefined when calling replacePermission.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(permission, "Permission")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Permission;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Permission");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update properties of an existing Permission
     * @param username a valid username string
     * @param type 
     * @param typeId 
     * @param id 
     * @param permission 
     */
    public updatePermission (username: string, type: string, typeId: string, id: string, permission: Permission) : Promise<{ response: http.ClientResponse; body: Permission;  }> {
        const localVarPath = this.basePath + '/{username}/{type}/{type_id}/acl/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'type' + '}', encodeURIComponent(String(type)))
            .replace('{' + 'type_id' + '}', encodeURIComponent(String(typeId)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling updatePermission.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling updatePermission.');
        }

        // verify required parameter 'typeId' is not null or undefined
        if (typeId === null || typeId === undefined) {
            throw new Error('Required parameter typeId was null or undefined when calling updatePermission.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePermission.');
        }

        // verify required parameter 'permission' is not null or undefined
        if (permission === null || permission === undefined) {
            throw new Error('Required parameter permission was null or undefined when calling updatePermission.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(permission, "Permission")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Permission;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Permission");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TokensApiApiKeys {
    HeaderKey,
    HeaderSignature,
    QueryKey,
}

export class TokensApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'HeaderKey': new ApiKeyAuth('header', 'X-AIO-Key'),
        'HeaderSignature': new ApiKeyAuth('header', 'X-AIO-Signature'),
        'QueryKey': new ApiKeyAuth('query', 'X-AIO-Key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TokensApiApiKeys, value: string) {
        (this.authentications as any)[TokensApiApiKeys[key]].apiKey = value;
    }
    /**
     * The Tokens endpoint returns information about the user's tokens. 
     * @summary All tokens for current user
     * @param username a valid username string
     */
    public allTokens (username: string) : Promise<{ response: http.ClientResponse; body: Array<Token>;  }> {
        const localVarPath = this.basePath + '/{username}/tokens'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling allTokens.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Token>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Token>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new Token
     * @param username a valid username string
     * @param token 
     */
    public createToken (username: string, token: Token) : Promise<{ response: http.ClientResponse; body: Token;  }> {
        const localVarPath = this.basePath + '/{username}/tokens'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling createToken.');
        }

        // verify required parameter 'token' is not null or undefined
        if (token === null || token === undefined) {
            throw new Error('Required parameter token was null or undefined when calling createToken.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(token, "Token")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Token;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Token");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an existing Token
     * @param username a valid username string
     * @param id 
     */
    public destroyToken (username: string, id: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/{username}/tokens/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling destroyToken.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling destroyToken.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns Token based on ID
     * @param username a valid username string
     * @param id 
     */
    public getToken (username: string, id: string) : Promise<{ response: http.ClientResponse; body: Token;  }> {
        const localVarPath = this.basePath + '/{username}/tokens/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling getToken.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getToken.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Token;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Token");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Replace an existing Token
     * @param username a valid username string
     * @param id 
     * @param token 
     */
    public replaceToken (username: string, id: string, token: Token) : Promise<{ response: http.ClientResponse; body: Token;  }> {
        const localVarPath = this.basePath + '/{username}/tokens/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling replaceToken.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling replaceToken.');
        }

        // verify required parameter 'token' is not null or undefined
        if (token === null || token === undefined) {
            throw new Error('Required parameter token was null or undefined when calling replaceToken.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(token, "Token")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Token;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Token");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update properties of an existing Token
     * @param username a valid username string
     * @param id 
     * @param token 
     */
    public updateToken (username: string, id: string, token: Token) : Promise<{ response: http.ClientResponse; body: Token;  }> {
        const localVarPath = this.basePath + '/{username}/tokens/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling updateToken.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateToken.');
        }

        // verify required parameter 'token' is not null or undefined
        if (token === null || token === undefined) {
            throw new Error('Required parameter token was null or undefined when calling updateToken.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(token, "Token")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Token;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Token");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TriggersApiApiKeys {
    HeaderKey,
    HeaderSignature,
    QueryKey,
}

export class TriggersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'HeaderKey': new ApiKeyAuth('header', 'X-AIO-Key'),
        'HeaderSignature': new ApiKeyAuth('header', 'X-AIO-Signature'),
        'QueryKey': new ApiKeyAuth('query', 'X-AIO-Key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TriggersApiApiKeys, value: string) {
        (this.authentications as any)[TriggersApiApiKeys[key]].apiKey = value;
    }
    /**
     * The Triggers endpoint returns information about the user's triggers. 
     * @summary All triggers for current user
     * @param username a valid username string
     */
    public allTriggers (username: string) : Promise<{ response: http.ClientResponse; body: Array<Trigger>;  }> {
        const localVarPath = this.basePath + '/{username}/triggers'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling allTriggers.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Trigger>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Trigger>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new Trigger
     * @param username a valid username string
     * @param trigger 
     */
    public createTrigger (username: string, trigger: Trigger) : Promise<{ response: http.ClientResponse; body: Trigger;  }> {
        const localVarPath = this.basePath + '/{username}/triggers'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling createTrigger.');
        }

        // verify required parameter 'trigger' is not null or undefined
        if (trigger === null || trigger === undefined) {
            throw new Error('Required parameter trigger was null or undefined when calling createTrigger.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(trigger, "Trigger")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Trigger;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Trigger");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an existing Trigger
     * @param username a valid username string
     * @param id 
     */
    public destroyTrigger (username: string, id: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/{username}/triggers/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling destroyTrigger.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling destroyTrigger.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Returns Trigger based on ID
     * @param username a valid username string
     * @param id 
     */
    public getTrigger (username: string, id: string) : Promise<{ response: http.ClientResponse; body: Trigger;  }> {
        const localVarPath = this.basePath + '/{username}/triggers/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling getTrigger.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTrigger.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Trigger;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Trigger");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Replace an existing Trigger
     * @param username a valid username string
     * @param id 
     * @param trigger 
     */
    public replaceTrigger (username: string, id: string, trigger: Trigger) : Promise<{ response: http.ClientResponse; body: Trigger;  }> {
        const localVarPath = this.basePath + '/{username}/triggers/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling replaceTrigger.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling replaceTrigger.');
        }

        // verify required parameter 'trigger' is not null or undefined
        if (trigger === null || trigger === undefined) {
            throw new Error('Required parameter trigger was null or undefined when calling replaceTrigger.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(trigger, "Trigger")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Trigger;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Trigger");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update properties of an existing Trigger
     * @param username a valid username string
     * @param id 
     * @param trigger 
     */
    public updateTrigger (username: string, id: string, trigger: Trigger) : Promise<{ response: http.ClientResponse; body: Trigger;  }> {
        const localVarPath = this.basePath + '/{username}/triggers/{id}'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling updateTrigger.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTrigger.');
        }

        // verify required parameter 'trigger' is not null or undefined
        if (trigger === null || trigger === undefined) {
            throw new Error('Required parameter trigger was null or undefined when calling updateTrigger.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(trigger, "Trigger")
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Trigger;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Trigger");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UsersApiApiKeys {
    HeaderKey,
    HeaderSignature,
    QueryKey,
}

export class UsersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'HeaderKey': new ApiKeyAuth('header', 'X-AIO-Key'),
        'HeaderSignature': new ApiKeyAuth('header', 'X-AIO-Signature'),
        'QueryKey': new ApiKeyAuth('query', 'X-AIO-Key'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UsersApiApiKeys, value: string) {
        (this.authentications as any)[UsersApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get information about the current user
     */
    public currentUser () : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/user';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the user's data rate limit and current activity level.
     * @param username a valid username string
     */
    public getCurrentUserThrottle (username: string) : Promise<{ response: http.ClientResponse; body: InlineResponse200;  }> {
        const localVarPath = this.basePath + '/{username}/throttle'
            .replace('{' + 'username' + '}', encodeURIComponent(String(username)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling getCurrentUserThrottle.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.HeaderKey.applyToRequest(localVarRequestOptions);

        this.authentications.HeaderSignature.applyToRequest(localVarRequestOptions);

        this.authentications.QueryKey.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse200;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse200");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
}

